#include <memory>
#include <chrono>
#include <fstream>
#include <iostream>
#include <stdlib.h>

#include "rclcpp/rclcpp.hpp"
#include <rclcpp/qos.hpp>
#include <rmw/qos_profiles.h>

#include "lifecycle_manager_node.hpp"

#include "custom_msgs/srv/driverless_status.hpp"
#include "custom_msgs/msg/driverless_status.hpp"

//TODO: Ola prepei na alaksoun se asychrona!!!

using lifecycle_msgs::msg::Transition;

namespace lifecycle_manager_namespace
{
    LifecycleManagerNode::LifecycleManagerNode() : Node("p23_lifecycle_manager")
    {

        currentDVStatus = STARTUP;
        currentASStatus = AS_OFF;
        currentMission = INSPECTION;

        initializeServices();
        
        loadParameters();

        // Read Node List from parameters
        get_parameter("managing_node_list", nodeList);

        // Initialize the lifecycle clients for each node that is managed by this manager. The services are automatically
        // generated by the lifecycle nodes

        initializeLifecycleClients(nodeList);
    }

    void LifecycleManagerNode::initializeServices()
    {
        using namespace std::placeholders;

        dvStatusService_ = create_service<custom_msgs::srv::DriverlessStatus>(
        std::string(get_name()) + std::string("/change_driverless_status"),
        std::bind(&LifecycleManagerNode::changeDVState, this, _1, _2)
        );
    }

    void LifecycleManagerNode::initializeLifecycleClients(std::vector<std::string> nodeList)
    {
        for (auto s: nodeList) {
            std::string getStateServiceName = s + std::string("/get_state");
            std::string changeStateServiceName = s + std::string("/change_state");
            lifecycleGetStateMap[s] = create_client<lifecycle_msgs::srv::GetState>(getStateServiceName);
            lifecycleChangeStateMap[s] = create_client<lifecycle_msgs::srv::ChangeState>(changeStateServiceName);
        }
    }

    unsigned int LifecycleManagerNode::getNodeState(std::string nodeName)
    {   
        using namespace std::chrono_literals;

        auto getStateServiceHandler = lifecycleGetStateMap.at(nodeName);

        auto request = std::make_shared<lifecycle_msgs::srv::GetState::Request>();

        if (!getStateServiceHandler->wait_for_service(1s)) {
        RCLCPP_ERROR(
            get_logger(),
            "Service %s is not available.",
            getStateServiceHandler->get_service_name());
        return lifecycle_msgs::msg::State::PRIMARY_STATE_UNKNOWN;
        }


        using ServiceResponseFuture = rclcpp::Client<lifecycle_msgs::srv::GetState>::SharedFuture;
        auto response_received_callback = [this, nodeName](ServiceResponseFuture future) {
            auto result = future.get();

            std::string nodeStatus = result->current_state.label.c_str();
            RCLCPP_INFO(get_logger(), "Status of node %s is %s", nodeName.c_str(), nodeStatus);
            return result->current_state.id;
        };

        auto future_result = getStateServiceHandler->async_send_request(request, response_received_callback);

        return 1;
    }

    bool LifecycleManagerNode::changeNodeState(std::uint8_t transition, std::string nodeName)
    {
        using namespace std::chrono_literals;

        auto changeStateServiceHandler = lifecycleChangeStateMap.at(nodeName);

        auto request = std::make_shared<lifecycle_msgs::srv::ChangeState::Request>();

        request->transition.id = transition;

        if (!changeStateServiceHandler->wait_for_service(1s)) {
             RCLCPP_ERROR(
                get_logger(),
                "Service %s is not available.",
                changeStateServiceHandler->get_service_name());
            return false;
        }

        using ServiceResponseFuture = rclcpp::Client<lifecycle_msgs::srv::ChangeState>::SharedFuture;
        auto response_received_callback = [this, nodeName](ServiceResponseFuture future) {
            auto result = future.get();

            bool nodeStatusChangeSuccess = result.get()->success;

            if (nodeStatusChangeSuccess) {
                RCLCPP_INFO(get_logger(), "Changed Status of node %s", nodeName.c_str());
                return true;
            }
            else {
                RCLCPP_INFO(get_logger(), "Couldn't change status of node %s", nodeName.c_str());
                return false;
            }
        };

        auto future_result = changeStateServiceHandler->async_send_request(request, response_received_callback);

        return true;
    }


    void LifecycleManagerNode::changeDVState(const std::shared_ptr<custom_msgs::srv::DriverlessStatus::Request> request,
        std::shared_ptr<custom_msgs::srv::DriverlessStatus::Response> response)
    {   
        DV_Status newDVStatus = static_cast<DV_Status>(request->new_status.id);

        // check if dv status changes successfully
        bool success = false;

        if (currentDVStatus == newDVStatus) {
            RCLCPP_INFO(get_logger(), "Already in this state, skipping request");
            // return false;
        }

        else {
            switch(newDVStatus){
                case(STARTUP):
                    break;
                case(LV_ON):
                    success = LV_On();
                    break;
                case(MISSION_SELECTED):
                    success = Mission_Selected();
                    break;
                case(DV_READY):
                    success = DV_Ready();
                    break;
                case(DV_DRIVING):
                    success = DV_Driving();
                    break;
                case(NODE_PROBLEM):
                    break;
            }
        }
        response->success = success;

        if (success)
            currentDVStatus = newDVStatus;
    }

    bool LifecycleManagerNode::verifyDVState()
    {
        return true;
    }


    /*
        The 4 Main DV States that the car should be in.
    */
    bool LifecycleManagerNode::LV_On()
    {
        bool inferenceSuccess = changeNodeState(Transition::TRANSITION_CONFIGURE, "inference");
        return inferenceSuccess;
    }

    bool LifecycleManagerNode::Mission_Selected()
    {
        return true;
    }

    bool LifecycleManagerNode::DV_Ready()
    {
        return true;
    }

    bool LifecycleManagerNode::DV_Driving()
    {
        return true;
    }

    void LifecycleManagerNode::loadParameters()
    {
        declare_parameter<std::vector<std::string>>("managing_node_list",
        {   "acquisition_left", "acquisition_right", "acquisition_center", "inference",
            "velocity_estimation", "slam", "saltas"
        });
    }

}